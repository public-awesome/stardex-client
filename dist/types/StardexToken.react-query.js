"use strict";
/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStardexTokenTransferMutation = exports.useStardexTokenBurnMutation = exports.useStardexTokenSendMutation = exports.useStardexTokenIncreaseAllowanceMutation = exports.useStardexTokenDecreaseAllowanceMutation = exports.useStardexTokenTransferFromMutation = exports.useStardexTokenSendFromMutation = exports.useStardexTokenBurnFromMutation = exports.useStardexTokenMintMutation = exports.useStardexTokenUpdateMinterMutation = exports.useStardexTokenUpdateMarketingMutation = exports.useStardexTokenUploadLogoMutation = exports.useStardexTokenBalanceQuery = exports.useStardexTokenTokenInfoQuery = exports.useStardexTokenMinterQuery = exports.useStardexTokenAllowanceQuery = exports.useStardexTokenAllAllowancesQuery = exports.useStardexTokenAllSpenderAllowancesQuery = exports.useStardexTokenAllAccountsQuery = exports.useStardexTokenMarketingInfoQuery = exports.useStardexTokenDownloadLogoQuery = exports.stardexTokenQueries = exports.stardexTokenQueryKeys = void 0;
const react_query_1 = require("@tanstack/react-query");
exports.stardexTokenQueryKeys = {
    contract: [{
            contract: "stardexToken"
        }],
    address: (contractAddress) => [{
            ...exports.stardexTokenQueryKeys.contract[0],
            address: contractAddress
        }],
    balance: (contractAddress, args) => [{
            ...exports.stardexTokenQueryKeys.address(contractAddress)[0],
            method: "balance",
            args
        }],
    tokenInfo: (contractAddress, args) => [{
            ...exports.stardexTokenQueryKeys.address(contractAddress)[0],
            method: "token_info",
            args
        }],
    minter: (contractAddress, args) => [{
            ...exports.stardexTokenQueryKeys.address(contractAddress)[0],
            method: "minter",
            args
        }],
    allowance: (contractAddress, args) => [{
            ...exports.stardexTokenQueryKeys.address(contractAddress)[0],
            method: "allowance",
            args
        }],
    allAllowances: (contractAddress, args) => [{
            ...exports.stardexTokenQueryKeys.address(contractAddress)[0],
            method: "all_allowances",
            args
        }],
    allSpenderAllowances: (contractAddress, args) => [{
            ...exports.stardexTokenQueryKeys.address(contractAddress)[0],
            method: "all_spender_allowances",
            args
        }],
    allAccounts: (contractAddress, args) => [{
            ...exports.stardexTokenQueryKeys.address(contractAddress)[0],
            method: "all_accounts",
            args
        }],
    marketingInfo: (contractAddress, args) => [{
            ...exports.stardexTokenQueryKeys.address(contractAddress)[0],
            method: "marketing_info",
            args
        }],
    downloadLogo: (contractAddress, args) => [{
            ...exports.stardexTokenQueryKeys.address(contractAddress)[0],
            method: "download_logo",
            args
        }]
};
exports.stardexTokenQueries = {
    balance: ({ client, args, options }) => ({
        queryKey: exports.stardexTokenQueryKeys.balance(client?.contractAddress, args),
        queryFn: () => client ? client.balance({
            address: args.address
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    tokenInfo: ({ client, options }) => ({
        queryKey: exports.stardexTokenQueryKeys.tokenInfo(client?.contractAddress),
        queryFn: () => client ? client.tokenInfo() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    minter: ({ client, options }) => ({
        queryKey: exports.stardexTokenQueryKeys.minter(client?.contractAddress),
        queryFn: () => client ? client.minter() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    allowance: ({ client, args, options }) => ({
        queryKey: exports.stardexTokenQueryKeys.allowance(client?.contractAddress, args),
        queryFn: () => client ? client.allowance({
            owner: args.owner,
            spender: args.spender
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    allAllowances: ({ client, args, options }) => ({
        queryKey: exports.stardexTokenQueryKeys.allAllowances(client?.contractAddress, args),
        queryFn: () => client ? client.allAllowances({
            limit: args.limit,
            owner: args.owner,
            startAfter: args.startAfter
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    allSpenderAllowances: ({ client, args, options }) => ({
        queryKey: exports.stardexTokenQueryKeys.allSpenderAllowances(client?.contractAddress, args),
        queryFn: () => client ? client.allSpenderAllowances({
            limit: args.limit,
            spender: args.spender,
            startAfter: args.startAfter
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    allAccounts: ({ client, args, options }) => ({
        queryKey: exports.stardexTokenQueryKeys.allAccounts(client?.contractAddress, args),
        queryFn: () => client ? client.allAccounts({
            limit: args.limit,
            startAfter: args.startAfter
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    marketingInfo: ({ client, options }) => ({
        queryKey: exports.stardexTokenQueryKeys.marketingInfo(client?.contractAddress),
        queryFn: () => client ? client.marketingInfo() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    downloadLogo: ({ client, options }) => ({
        queryKey: exports.stardexTokenQueryKeys.downloadLogo(client?.contractAddress),
        queryFn: () => client ? client.downloadLogo() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    })
};
function useStardexTokenDownloadLogoQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexTokenQueryKeys.downloadLogo(client?.contractAddress), () => client ? client.downloadLogo() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexTokenDownloadLogoQuery = useStardexTokenDownloadLogoQuery;
function useStardexTokenMarketingInfoQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexTokenQueryKeys.marketingInfo(client?.contractAddress), () => client ? client.marketingInfo() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexTokenMarketingInfoQuery = useStardexTokenMarketingInfoQuery;
function useStardexTokenAllAccountsQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexTokenQueryKeys.allAccounts(client?.contractAddress, args), () => client ? client.allAccounts({
        limit: args.limit,
        startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexTokenAllAccountsQuery = useStardexTokenAllAccountsQuery;
function useStardexTokenAllSpenderAllowancesQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexTokenQueryKeys.allSpenderAllowances(client?.contractAddress, args), () => client ? client.allSpenderAllowances({
        limit: args.limit,
        spender: args.spender,
        startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexTokenAllSpenderAllowancesQuery = useStardexTokenAllSpenderAllowancesQuery;
function useStardexTokenAllAllowancesQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexTokenQueryKeys.allAllowances(client?.contractAddress, args), () => client ? client.allAllowances({
        limit: args.limit,
        owner: args.owner,
        startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexTokenAllAllowancesQuery = useStardexTokenAllAllowancesQuery;
function useStardexTokenAllowanceQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexTokenQueryKeys.allowance(client?.contractAddress, args), () => client ? client.allowance({
        owner: args.owner,
        spender: args.spender
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexTokenAllowanceQuery = useStardexTokenAllowanceQuery;
function useStardexTokenMinterQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexTokenQueryKeys.minter(client?.contractAddress), () => client ? client.minter() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexTokenMinterQuery = useStardexTokenMinterQuery;
function useStardexTokenTokenInfoQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexTokenQueryKeys.tokenInfo(client?.contractAddress), () => client ? client.tokenInfo() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexTokenTokenInfoQuery = useStardexTokenTokenInfoQuery;
function useStardexTokenBalanceQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexTokenQueryKeys.balance(client?.contractAddress, args), () => client ? client.balance({
        address: args.address
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexTokenBalanceQuery = useStardexTokenBalanceQuery;
function useStardexTokenUploadLogoMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.uploadLogo(msg, fee, memo, funds), options);
}
exports.useStardexTokenUploadLogoMutation = useStardexTokenUploadLogoMutation;
function useStardexTokenUpdateMarketingMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.updateMarketing(msg, fee, memo, funds), options);
}
exports.useStardexTokenUpdateMarketingMutation = useStardexTokenUpdateMarketingMutation;
function useStardexTokenUpdateMinterMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.updateMinter(msg, fee, memo, funds), options);
}
exports.useStardexTokenUpdateMinterMutation = useStardexTokenUpdateMinterMutation;
function useStardexTokenMintMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.mint(msg, fee, memo, funds), options);
}
exports.useStardexTokenMintMutation = useStardexTokenMintMutation;
function useStardexTokenBurnFromMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.burnFrom(msg, fee, memo, funds), options);
}
exports.useStardexTokenBurnFromMutation = useStardexTokenBurnFromMutation;
function useStardexTokenSendFromMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.sendFrom(msg, fee, memo, funds), options);
}
exports.useStardexTokenSendFromMutation = useStardexTokenSendFromMutation;
function useStardexTokenTransferFromMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.transferFrom(msg, fee, memo, funds), options);
}
exports.useStardexTokenTransferFromMutation = useStardexTokenTransferFromMutation;
function useStardexTokenDecreaseAllowanceMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.decreaseAllowance(msg, fee, memo, funds), options);
}
exports.useStardexTokenDecreaseAllowanceMutation = useStardexTokenDecreaseAllowanceMutation;
function useStardexTokenIncreaseAllowanceMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.increaseAllowance(msg, fee, memo, funds), options);
}
exports.useStardexTokenIncreaseAllowanceMutation = useStardexTokenIncreaseAllowanceMutation;
function useStardexTokenSendMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.send(msg, fee, memo, funds), options);
}
exports.useStardexTokenSendMutation = useStardexTokenSendMutation;
function useStardexTokenBurnMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.burn(msg, fee, memo, funds), options);
}
exports.useStardexTokenBurnMutation = useStardexTokenBurnMutation;
function useStardexTokenTransferMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.transfer(msg, fee, memo, funds), options);
}
exports.useStardexTokenTransferMutation = useStardexTokenTransferMutation;
