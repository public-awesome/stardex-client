/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { AssetInfo, Addr, Binary, InstantiateMsg, ExecuteMsg, Uint128, Decimal, Cw20ReceiveMsg, Asset, QueryMsg, Uint64, MigrateMsg, NullableUint128, Decimal256, ConfigResponse, CumulativePricesResponse, OracleObservation, PairType, PairInfo, PoolResponse, ReverseSimulationResponse, ArrayOfAsset, SimulationResponse } from "./StardexPairConcentrated.types";
import { StardexPairConcentratedQueryClient, StardexPairConcentratedClient } from "./StardexPairConcentrated.client";
export const stardexPairConcentratedQueryKeys = {
  contract: ([{
    contract: "stardexPairConcentrated"
  }] as const),
  address: (contractAddress: string | undefined) => ([{
    ...stardexPairConcentratedQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  pair: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "pair",
    args
  }] as const),
  pool: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "pool",
    args
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  share: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "share",
    args
  }] as const),
  simulation: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "simulation",
    args
  }] as const),
  reverseSimulation: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "reverse_simulation",
    args
  }] as const),
  cumulativePrices: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "cumulative_prices",
    args
  }] as const),
  computeD: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "compute_d",
    args
  }] as const),
  lpPrice: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "lp_price",
    args
  }] as const),
  assetBalanceAt: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "asset_balance_at",
    args
  }] as const),
  observe: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "observe",
    args
  }] as const),
  simulateProvide: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "simulate_provide",
    args
  }] as const),
  simulateWithdraw: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairConcentratedQueryKeys.address(contractAddress)[0],
    method: "simulate_withdraw",
    args
  }] as const)
};
export const stardexPairConcentratedQueries = {
  pair: <TData = PairInfo,>({
    client,
    options
  }: StardexPairConcentratedPairQuery<TData>): UseQueryOptions<PairInfo, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.pair(client?.contractAddress),
    queryFn: () => client ? client.pair() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  pool: <TData = PoolResponse,>({
    client,
    options
  }: StardexPairConcentratedPoolQuery<TData>): UseQueryOptions<PoolResponse, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.pool(client?.contractAddress),
    queryFn: () => client ? client.pool() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  config: <TData = ConfigResponse,>({
    client,
    options
  }: StardexPairConcentratedConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  share: <TData = ArrayOfAsset,>({
    client,
    args,
    options
  }: StardexPairConcentratedShareQuery<TData>): UseQueryOptions<ArrayOfAsset, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.share(client?.contractAddress, args),
    queryFn: () => client ? client.share({
      amount: args.amount
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  simulation: <TData = SimulationResponse,>({
    client,
    args,
    options
  }: StardexPairConcentratedSimulationQuery<TData>): UseQueryOptions<SimulationResponse, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.simulation(client?.contractAddress, args),
    queryFn: () => client ? client.simulation({
      askAssetInfo: args.askAssetInfo,
      offerAsset: args.offerAsset
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  reverseSimulation: <TData = ReverseSimulationResponse,>({
    client,
    args,
    options
  }: StardexPairConcentratedReverseSimulationQuery<TData>): UseQueryOptions<ReverseSimulationResponse, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.reverseSimulation(client?.contractAddress, args),
    queryFn: () => client ? client.reverseSimulation({
      askAsset: args.askAsset,
      offerAssetInfo: args.offerAssetInfo
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  cumulativePrices: <TData = CumulativePricesResponse,>({
    client,
    options
  }: StardexPairConcentratedCumulativePricesQuery<TData>): UseQueryOptions<CumulativePricesResponse, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.cumulativePrices(client?.contractAddress),
    queryFn: () => client ? client.cumulativePrices() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  computeD: <TData = Decimal256,>({
    client,
    options
  }: StardexPairConcentratedComputeDQuery<TData>): UseQueryOptions<Decimal256, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.computeD(client?.contractAddress),
    queryFn: () => client ? client.computeD() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  lpPrice: <TData = Decimal256,>({
    client,
    options
  }: StardexPairConcentratedLpPriceQuery<TData>): UseQueryOptions<Decimal256, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.lpPrice(client?.contractAddress),
    queryFn: () => client ? client.lpPrice() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  assetBalanceAt: <TData = NullableUint128,>({
    client,
    args,
    options
  }: StardexPairConcentratedAssetBalanceAtQuery<TData>): UseQueryOptions<NullableUint128, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.assetBalanceAt(client?.contractAddress, args),
    queryFn: () => client ? client.assetBalanceAt({
      assetInfo: args.assetInfo,
      blockHeight: args.blockHeight
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  observe: <TData = OracleObservation,>({
    client,
    args,
    options
  }: StardexPairConcentratedObserveQuery<TData>): UseQueryOptions<OracleObservation, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.observe(client?.contractAddress, args),
    queryFn: () => client ? client.observe({
      secondsAgo: args.secondsAgo
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  simulateProvide: <TData = Uint128,>({
    client,
    args,
    options
  }: StardexPairConcentratedSimulateProvideQuery<TData>): UseQueryOptions<Uint128, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.simulateProvide(client?.contractAddress, args),
    queryFn: () => client ? client.simulateProvide({
      assets: args.assets,
      slippageTolerance: args.slippageTolerance
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  simulateWithdraw: <TData = ArrayOfAsset,>({
    client,
    args,
    options
  }: StardexPairConcentratedSimulateWithdrawQuery<TData>): UseQueryOptions<ArrayOfAsset, Error, TData> => ({
    queryKey: stardexPairConcentratedQueryKeys.simulateWithdraw(client?.contractAddress, args),
    queryFn: () => client ? client.simulateWithdraw({
      lpAmount: args.lpAmount
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface StardexPairConcentratedReactQuery<TResponse, TData = TResponse> {
  client: StardexPairConcentratedQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface StardexPairConcentratedSimulateWithdrawQuery<TData> extends StardexPairConcentratedReactQuery<ArrayOfAsset, TData> {
  args: {
    lpAmount: Uint128;
  };
}
export function useStardexPairConcentratedSimulateWithdrawQuery<TData = ArrayOfAsset>({
  client,
  args,
  options
}: StardexPairConcentratedSimulateWithdrawQuery<TData>) {
  return useQuery<ArrayOfAsset, Error, TData>(stardexPairConcentratedQueryKeys.simulateWithdraw(client?.contractAddress, args), () => client ? client.simulateWithdraw({
    lpAmount: args.lpAmount
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedSimulateProvideQuery<TData> extends StardexPairConcentratedReactQuery<Uint128, TData> {
  args: {
    assets: Asset[];
    slippageTolerance?: Decimal;
  };
}
export function useStardexPairConcentratedSimulateProvideQuery<TData = Uint128>({
  client,
  args,
  options
}: StardexPairConcentratedSimulateProvideQuery<TData>) {
  return useQuery<Uint128, Error, TData>(stardexPairConcentratedQueryKeys.simulateProvide(client?.contractAddress, args), () => client ? client.simulateProvide({
    assets: args.assets,
    slippageTolerance: args.slippageTolerance
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedObserveQuery<TData> extends StardexPairConcentratedReactQuery<OracleObservation, TData> {
  args: {
    secondsAgo: number;
  };
}
export function useStardexPairConcentratedObserveQuery<TData = OracleObservation>({
  client,
  args,
  options
}: StardexPairConcentratedObserveQuery<TData>) {
  return useQuery<OracleObservation, Error, TData>(stardexPairConcentratedQueryKeys.observe(client?.contractAddress, args), () => client ? client.observe({
    secondsAgo: args.secondsAgo
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedAssetBalanceAtQuery<TData> extends StardexPairConcentratedReactQuery<NullableUint128, TData> {
  args: {
    assetInfo: AssetInfo;
    blockHeight: Uint64;
  };
}
export function useStardexPairConcentratedAssetBalanceAtQuery<TData = NullableUint128>({
  client,
  args,
  options
}: StardexPairConcentratedAssetBalanceAtQuery<TData>) {
  return useQuery<NullableUint128, Error, TData>(stardexPairConcentratedQueryKeys.assetBalanceAt(client?.contractAddress, args), () => client ? client.assetBalanceAt({
    assetInfo: args.assetInfo,
    blockHeight: args.blockHeight
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedLpPriceQuery<TData> extends StardexPairConcentratedReactQuery<Decimal256, TData> {}
export function useStardexPairConcentratedLpPriceQuery<TData = Decimal256>({
  client,
  options
}: StardexPairConcentratedLpPriceQuery<TData>) {
  return useQuery<Decimal256, Error, TData>(stardexPairConcentratedQueryKeys.lpPrice(client?.contractAddress), () => client ? client.lpPrice() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedComputeDQuery<TData> extends StardexPairConcentratedReactQuery<Decimal256, TData> {}
export function useStardexPairConcentratedComputeDQuery<TData = Decimal256>({
  client,
  options
}: StardexPairConcentratedComputeDQuery<TData>) {
  return useQuery<Decimal256, Error, TData>(stardexPairConcentratedQueryKeys.computeD(client?.contractAddress), () => client ? client.computeD() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedCumulativePricesQuery<TData> extends StardexPairConcentratedReactQuery<CumulativePricesResponse, TData> {}
export function useStardexPairConcentratedCumulativePricesQuery<TData = CumulativePricesResponse>({
  client,
  options
}: StardexPairConcentratedCumulativePricesQuery<TData>) {
  return useQuery<CumulativePricesResponse, Error, TData>(stardexPairConcentratedQueryKeys.cumulativePrices(client?.contractAddress), () => client ? client.cumulativePrices() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedReverseSimulationQuery<TData> extends StardexPairConcentratedReactQuery<ReverseSimulationResponse, TData> {
  args: {
    askAsset: Asset;
    offerAssetInfo?: AssetInfo;
  };
}
export function useStardexPairConcentratedReverseSimulationQuery<TData = ReverseSimulationResponse>({
  client,
  args,
  options
}: StardexPairConcentratedReverseSimulationQuery<TData>) {
  return useQuery<ReverseSimulationResponse, Error, TData>(stardexPairConcentratedQueryKeys.reverseSimulation(client?.contractAddress, args), () => client ? client.reverseSimulation({
    askAsset: args.askAsset,
    offerAssetInfo: args.offerAssetInfo
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedSimulationQuery<TData> extends StardexPairConcentratedReactQuery<SimulationResponse, TData> {
  args: {
    askAssetInfo?: AssetInfo;
    offerAsset: Asset;
  };
}
export function useStardexPairConcentratedSimulationQuery<TData = SimulationResponse>({
  client,
  args,
  options
}: StardexPairConcentratedSimulationQuery<TData>) {
  return useQuery<SimulationResponse, Error, TData>(stardexPairConcentratedQueryKeys.simulation(client?.contractAddress, args), () => client ? client.simulation({
    askAssetInfo: args.askAssetInfo,
    offerAsset: args.offerAsset
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedShareQuery<TData> extends StardexPairConcentratedReactQuery<ArrayOfAsset, TData> {
  args: {
    amount: Uint128;
  };
}
export function useStardexPairConcentratedShareQuery<TData = ArrayOfAsset>({
  client,
  args,
  options
}: StardexPairConcentratedShareQuery<TData>) {
  return useQuery<ArrayOfAsset, Error, TData>(stardexPairConcentratedQueryKeys.share(client?.contractAddress, args), () => client ? client.share({
    amount: args.amount
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedConfigQuery<TData> extends StardexPairConcentratedReactQuery<ConfigResponse, TData> {}
export function useStardexPairConcentratedConfigQuery<TData = ConfigResponse>({
  client,
  options
}: StardexPairConcentratedConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(stardexPairConcentratedQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedPoolQuery<TData> extends StardexPairConcentratedReactQuery<PoolResponse, TData> {}
export function useStardexPairConcentratedPoolQuery<TData = PoolResponse>({
  client,
  options
}: StardexPairConcentratedPoolQuery<TData>) {
  return useQuery<PoolResponse, Error, TData>(stardexPairConcentratedQueryKeys.pool(client?.contractAddress), () => client ? client.pool() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedPairQuery<TData> extends StardexPairConcentratedReactQuery<PairInfo, TData> {}
export function useStardexPairConcentratedPairQuery<TData = PairInfo>({
  client,
  options
}: StardexPairConcentratedPairQuery<TData>) {
  return useQuery<PairInfo, Error, TData>(stardexPairConcentratedQueryKeys.pair(client?.contractAddress), () => client ? client.pair() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConcentratedClaimOwnershipMutation {
  client: StardexPairConcentratedClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairConcentratedClaimOwnershipMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairConcentratedClaimOwnershipMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairConcentratedClaimOwnershipMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.claimOwnership(fee, memo, funds), options);
}
export interface StardexPairConcentratedDropOwnershipProposalMutation {
  client: StardexPairConcentratedClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairConcentratedDropOwnershipProposalMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairConcentratedDropOwnershipProposalMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairConcentratedDropOwnershipProposalMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.dropOwnershipProposal(fee, memo, funds), options);
}
export interface StardexPairConcentratedProposeNewOwnerMutation {
  client: StardexPairConcentratedClient;
  msg: {
    expiresIn: number;
    owner: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairConcentratedProposeNewOwnerMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairConcentratedProposeNewOwnerMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairConcentratedProposeNewOwnerMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.proposeNewOwner(msg, fee, memo, funds), options);
}
export interface StardexPairConcentratedUpdateConfigMutation {
  client: StardexPairConcentratedClient;
  msg: {
    params: Binary;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairConcentratedUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairConcentratedUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairConcentratedUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}
export interface StardexPairConcentratedSwapMutation {
  client: StardexPairConcentratedClient;
  msg: {
    askAssetInfo?: AssetInfo;
    beliefPrice?: Decimal;
    maxSpread?: Decimal;
    offerAsset: Asset;
    to?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairConcentratedSwapMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairConcentratedSwapMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairConcentratedSwapMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.swap(msg, fee, memo, funds), options);
}
export interface StardexPairConcentratedWithdrawLiquidityMutation {
  client: StardexPairConcentratedClient;
  msg: {
    assets?: Asset[];
    minAssetsToReceive?: Asset[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairConcentratedWithdrawLiquidityMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairConcentratedWithdrawLiquidityMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairConcentratedWithdrawLiquidityMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.withdrawLiquidity(msg, fee, memo, funds), options);
}
export interface StardexPairConcentratedProvideLiquidityMutation {
  client: StardexPairConcentratedClient;
  msg: {
    assets: Asset[];
    autoStake?: boolean;
    minLpToReceive?: Uint128;
    receiver?: string;
    slippageTolerance?: Decimal;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairConcentratedProvideLiquidityMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairConcentratedProvideLiquidityMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairConcentratedProvideLiquidityMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.provideLiquidity(msg, fee, memo, funds), options);
}
export interface StardexPairConcentratedReceiveMutation {
  client: StardexPairConcentratedClient;
  msg: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairConcentratedReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairConcentratedReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairConcentratedReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receive(msg, fee, memo, funds), options);
}