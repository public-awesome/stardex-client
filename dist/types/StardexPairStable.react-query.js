"use strict";
/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStardexPairStableReceiveMutation = exports.useStardexPairStableProvideLiquidityMutation = exports.useStardexPairStableWithdrawLiquidityMutation = exports.useStardexPairStableSwapMutation = exports.useStardexPairStableUpdateConfigMutation = exports.useStardexPairStableProposeNewOwnerMutation = exports.useStardexPairStableDropOwnershipProposalMutation = exports.useStardexPairStableClaimOwnershipMutation = exports.useStardexPairStablePairQuery = exports.useStardexPairStablePoolQuery = exports.useStardexPairStableConfigQuery = exports.useStardexPairStableShareQuery = exports.useStardexPairStableSimulationQuery = exports.useStardexPairStableReverseSimulationQuery = exports.useStardexPairStableCumulativePricesQuery = exports.useStardexPairStableQueryComputeDQuery = exports.useStardexPairStableAssetBalanceAtQuery = exports.useStardexPairStableObserveQuery = exports.useStardexPairStableSimulateWithdrawQuery = exports.useStardexPairStableSimulateProvideQuery = exports.stardexPairStableQueries = exports.stardexPairStableQueryKeys = void 0;
const react_query_1 = require("@tanstack/react-query");
exports.stardexPairStableQueryKeys = {
    contract: [{
            contract: "stardexPairStable"
        }],
    address: (contractAddress) => [{
            ...exports.stardexPairStableQueryKeys.contract[0],
            address: contractAddress
        }],
    pair: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "pair",
            args
        }],
    pool: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "pool",
            args
        }],
    config: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "config",
            args
        }],
    share: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "share",
            args
        }],
    simulation: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "simulation",
            args
        }],
    reverseSimulation: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "reverse_simulation",
            args
        }],
    cumulativePrices: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "cumulative_prices",
            args
        }],
    queryComputeD: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "query_compute_d",
            args
        }],
    assetBalanceAt: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "asset_balance_at",
            args
        }],
    observe: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "observe",
            args
        }],
    simulateWithdraw: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "simulate_withdraw",
            args
        }],
    simulateProvide: (contractAddress, args) => [{
            ...exports.stardexPairStableQueryKeys.address(contractAddress)[0],
            method: "simulate_provide",
            args
        }]
};
exports.stardexPairStableQueries = {
    pair: ({ client, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.pair(client?.contractAddress),
        queryFn: () => client ? client.pair() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    pool: ({ client, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.pool(client?.contractAddress),
        queryFn: () => client ? client.pool() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    config: ({ client, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.config(client?.contractAddress),
        queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    share: ({ client, args, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.share(client?.contractAddress, args),
        queryFn: () => client ? client.share({
            amount: args.amount
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    simulation: ({ client, args, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.simulation(client?.contractAddress, args),
        queryFn: () => client ? client.simulation({
            askAssetInfo: args.askAssetInfo,
            offerAsset: args.offerAsset
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    reverseSimulation: ({ client, args, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.reverseSimulation(client?.contractAddress, args),
        queryFn: () => client ? client.reverseSimulation({
            askAsset: args.askAsset,
            offerAssetInfo: args.offerAssetInfo
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    cumulativePrices: ({ client, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.cumulativePrices(client?.contractAddress),
        queryFn: () => client ? client.cumulativePrices() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    queryComputeD: ({ client, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.queryComputeD(client?.contractAddress),
        queryFn: () => client ? client.queryComputeD() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    assetBalanceAt: ({ client, args, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.assetBalanceAt(client?.contractAddress, args),
        queryFn: () => client ? client.assetBalanceAt({
            assetInfo: args.assetInfo,
            blockHeight: args.blockHeight
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    observe: ({ client, args, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.observe(client?.contractAddress, args),
        queryFn: () => client ? client.observe({
            secondsAgo: args.secondsAgo
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    simulateWithdraw: ({ client, args, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.simulateWithdraw(client?.contractAddress, args),
        queryFn: () => client ? client.simulateWithdraw({
            lpAmount: args.lpAmount
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    simulateProvide: ({ client, args, options }) => ({
        queryKey: exports.stardexPairStableQueryKeys.simulateProvide(client?.contractAddress, args),
        queryFn: () => client ? client.simulateProvide({
            assets: args.assets,
            slippageTolerance: args.slippageTolerance
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    })
};
function useStardexPairStableSimulateProvideQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.simulateProvide(client?.contractAddress, args), () => client ? client.simulateProvide({
        assets: args.assets,
        slippageTolerance: args.slippageTolerance
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStableSimulateProvideQuery = useStardexPairStableSimulateProvideQuery;
function useStardexPairStableSimulateWithdrawQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.simulateWithdraw(client?.contractAddress, args), () => client ? client.simulateWithdraw({
        lpAmount: args.lpAmount
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStableSimulateWithdrawQuery = useStardexPairStableSimulateWithdrawQuery;
function useStardexPairStableObserveQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.observe(client?.contractAddress, args), () => client ? client.observe({
        secondsAgo: args.secondsAgo
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStableObserveQuery = useStardexPairStableObserveQuery;
function useStardexPairStableAssetBalanceAtQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.assetBalanceAt(client?.contractAddress, args), () => client ? client.assetBalanceAt({
        assetInfo: args.assetInfo,
        blockHeight: args.blockHeight
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStableAssetBalanceAtQuery = useStardexPairStableAssetBalanceAtQuery;
function useStardexPairStableQueryComputeDQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.queryComputeD(client?.contractAddress), () => client ? client.queryComputeD() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStableQueryComputeDQuery = useStardexPairStableQueryComputeDQuery;
function useStardexPairStableCumulativePricesQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.cumulativePrices(client?.contractAddress), () => client ? client.cumulativePrices() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStableCumulativePricesQuery = useStardexPairStableCumulativePricesQuery;
function useStardexPairStableReverseSimulationQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.reverseSimulation(client?.contractAddress, args), () => client ? client.reverseSimulation({
        askAsset: args.askAsset,
        offerAssetInfo: args.offerAssetInfo
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStableReverseSimulationQuery = useStardexPairStableReverseSimulationQuery;
function useStardexPairStableSimulationQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.simulation(client?.contractAddress, args), () => client ? client.simulation({
        askAssetInfo: args.askAssetInfo,
        offerAsset: args.offerAsset
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStableSimulationQuery = useStardexPairStableSimulationQuery;
function useStardexPairStableShareQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.share(client?.contractAddress, args), () => client ? client.share({
        amount: args.amount
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStableShareQuery = useStardexPairStableShareQuery;
function useStardexPairStableConfigQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStableConfigQuery = useStardexPairStableConfigQuery;
function useStardexPairStablePoolQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.pool(client?.contractAddress), () => client ? client.pool() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStablePoolQuery = useStardexPairStablePoolQuery;
function useStardexPairStablePairQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairStableQueryKeys.pair(client?.contractAddress), () => client ? client.pair() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairStablePairQuery = useStardexPairStablePairQuery;
function useStardexPairStableClaimOwnershipMutation(options) {
    return (0, react_query_1.useMutation)(({ client, args: { fee, memo, funds } = {} }) => client.claimOwnership(fee, memo, funds), options);
}
exports.useStardexPairStableClaimOwnershipMutation = useStardexPairStableClaimOwnershipMutation;
function useStardexPairStableDropOwnershipProposalMutation(options) {
    return (0, react_query_1.useMutation)(({ client, args: { fee, memo, funds } = {} }) => client.dropOwnershipProposal(fee, memo, funds), options);
}
exports.useStardexPairStableDropOwnershipProposalMutation = useStardexPairStableDropOwnershipProposalMutation;
function useStardexPairStableProposeNewOwnerMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.proposeNewOwner(msg, fee, memo, funds), options);
}
exports.useStardexPairStableProposeNewOwnerMutation = useStardexPairStableProposeNewOwnerMutation;
function useStardexPairStableUpdateConfigMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.updateConfig(msg, fee, memo, funds), options);
}
exports.useStardexPairStableUpdateConfigMutation = useStardexPairStableUpdateConfigMutation;
function useStardexPairStableSwapMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.swap(msg, fee, memo, funds), options);
}
exports.useStardexPairStableSwapMutation = useStardexPairStableSwapMutation;
function useStardexPairStableWithdrawLiquidityMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.withdrawLiquidity(msg, fee, memo, funds), options);
}
exports.useStardexPairStableWithdrawLiquidityMutation = useStardexPairStableWithdrawLiquidityMutation;
function useStardexPairStableProvideLiquidityMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.provideLiquidity(msg, fee, memo, funds), options);
}
exports.useStardexPairStableProvideLiquidityMutation = useStardexPairStableProvideLiquidityMutation;
function useStardexPairStableReceiveMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.receive(msg, fee, memo, funds), options);
}
exports.useStardexPairStableReceiveMutation = useStardexPairStableReceiveMutation;
