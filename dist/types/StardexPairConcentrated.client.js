"use strict";
/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.StardexPairConcentratedClient = exports.StardexPairConcentratedQueryClient = void 0;
class StardexPairConcentratedQueryClient {
    client;
    contractAddress;
    constructor(client, contractAddress) {
        this.client = client;
        this.contractAddress = contractAddress;
        this.pair = this.pair.bind(this);
        this.pool = this.pool.bind(this);
        this.config = this.config.bind(this);
        this.share = this.share.bind(this);
        this.simulation = this.simulation.bind(this);
        this.reverseSimulation = this.reverseSimulation.bind(this);
        this.cumulativePrices = this.cumulativePrices.bind(this);
        this.computeD = this.computeD.bind(this);
        this.lpPrice = this.lpPrice.bind(this);
        this.assetBalanceAt = this.assetBalanceAt.bind(this);
        this.observe = this.observe.bind(this);
        this.simulateProvide = this.simulateProvide.bind(this);
        this.simulateWithdraw = this.simulateWithdraw.bind(this);
    }
    pair = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            pair: {}
        });
    };
    pool = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            pool: {}
        });
    };
    config = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            config: {}
        });
    };
    share = async ({ amount }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            share: {
                amount
            }
        });
    };
    simulation = async ({ askAssetInfo, offerAsset }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            simulation: {
                ask_asset_info: askAssetInfo,
                offer_asset: offerAsset
            }
        });
    };
    reverseSimulation = async ({ askAsset, offerAssetInfo }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            reverse_simulation: {
                ask_asset: askAsset,
                offer_asset_info: offerAssetInfo
            }
        });
    };
    cumulativePrices = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            cumulative_prices: {}
        });
    };
    computeD = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            compute_d: {}
        });
    };
    lpPrice = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            lp_price: {}
        });
    };
    assetBalanceAt = async ({ assetInfo, blockHeight }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            asset_balance_at: {
                asset_info: assetInfo,
                block_height: blockHeight
            }
        });
    };
    observe = async ({ secondsAgo }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            observe: {
                seconds_ago: secondsAgo
            }
        });
    };
    simulateProvide = async ({ assets, slippageTolerance }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            simulate_provide: {
                assets,
                slippage_tolerance: slippageTolerance
            }
        });
    };
    simulateWithdraw = async ({ lpAmount }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            simulate_withdraw: {
                lp_amount: lpAmount
            }
        });
    };
}
exports.StardexPairConcentratedQueryClient = StardexPairConcentratedQueryClient;
class StardexPairConcentratedClient extends StardexPairConcentratedQueryClient {
    client;
    sender;
    contractAddress;
    constructor(client, sender, contractAddress) {
        super(client, contractAddress);
        this.client = client;
        this.sender = sender;
        this.contractAddress = contractAddress;
        this.receive = this.receive.bind(this);
        this.provideLiquidity = this.provideLiquidity.bind(this);
        this.withdrawLiquidity = this.withdrawLiquidity.bind(this);
        this.swap = this.swap.bind(this);
        this.updateConfig = this.updateConfig.bind(this);
        this.proposeNewOwner = this.proposeNewOwner.bind(this);
        this.dropOwnershipProposal = this.dropOwnershipProposal.bind(this);
        this.claimOwnership = this.claimOwnership.bind(this);
    }
    receive = async ({ amount, msg, sender }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            receive: {
                amount,
                msg,
                sender
            }
        }, fee, memo, _funds);
    };
    provideLiquidity = async ({ assets, autoStake, minLpToReceive, receiver, slippageTolerance }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            provide_liquidity: {
                assets,
                auto_stake: autoStake,
                min_lp_to_receive: minLpToReceive,
                receiver,
                slippage_tolerance: slippageTolerance
            }
        }, fee, memo, _funds);
    };
    withdrawLiquidity = async ({ assets, minAssetsToReceive }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            withdraw_liquidity: {
                assets,
                min_assets_to_receive: minAssetsToReceive
            }
        }, fee, memo, _funds);
    };
    swap = async ({ askAssetInfo, beliefPrice, maxSpread, offerAsset, to }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            swap: {
                ask_asset_info: askAssetInfo,
                belief_price: beliefPrice,
                max_spread: maxSpread,
                offer_asset: offerAsset,
                to
            }
        }, fee, memo, _funds);
    };
    updateConfig = async ({ params }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            update_config: {
                params
            }
        }, fee, memo, _funds);
    };
    proposeNewOwner = async ({ expiresIn, owner }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            propose_new_owner: {
                expires_in: expiresIn,
                owner
            }
        }, fee, memo, _funds);
    };
    dropOwnershipProposal = async (fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            drop_ownership_proposal: {}
        }, fee, memo, _funds);
    };
    claimOwnership = async (fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            claim_ownership: {}
        }, fee, memo, _funds);
    };
}
exports.StardexPairConcentratedClient = StardexPairConcentratedClient;
