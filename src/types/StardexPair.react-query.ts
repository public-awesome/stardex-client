/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { AssetInfo, Addr, Binary, InstantiateMsg, ExecuteMsg, Uint128, Decimal, Cw20ReceiveMsg, Asset, QueryMsg, Uint64, MigrateMsg, NullableUint128, ConfigResponse, CumulativePricesResponse, OracleObservation, PairType, PairInfo, PoolResponse, ReverseSimulationResponse, ArrayOfAsset, SimulationResponse } from "./StardexPair.types";
import { StardexPairQueryClient, StardexPairClient } from "./StardexPair.client";
export const stardexPairQueryKeys = {
  contract: ([{
    contract: "stardexPair"
  }] as const),
  address: (contractAddress: string | undefined) => ([{
    ...stardexPairQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  pair: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "pair",
    args
  }] as const),
  pool: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "pool",
    args
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  share: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "share",
    args
  }] as const),
  simulation: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "simulation",
    args
  }] as const),
  reverseSimulation: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "reverse_simulation",
    args
  }] as const),
  cumulativePrices: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "cumulative_prices",
    args
  }] as const),
  queryComputeD: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "query_compute_d",
    args
  }] as const),
  assetBalanceAt: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "asset_balance_at",
    args
  }] as const),
  observe: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "observe",
    args
  }] as const),
  simulateWithdraw: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "simulate_withdraw",
    args
  }] as const),
  simulateProvide: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...stardexPairQueryKeys.address(contractAddress)[0],
    method: "simulate_provide",
    args
  }] as const)
};
export const stardexPairQueries = {
  pair: <TData = PairInfo,>({
    client,
    options
  }: StardexPairPairQuery<TData>): UseQueryOptions<PairInfo, Error, TData> => ({
    queryKey: stardexPairQueryKeys.pair(client?.contractAddress),
    queryFn: () => client ? client.pair() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  pool: <TData = PoolResponse,>({
    client,
    options
  }: StardexPairPoolQuery<TData>): UseQueryOptions<PoolResponse, Error, TData> => ({
    queryKey: stardexPairQueryKeys.pool(client?.contractAddress),
    queryFn: () => client ? client.pool() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  config: <TData = ConfigResponse,>({
    client,
    options
  }: StardexPairConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: stardexPairQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  share: <TData = ArrayOfAsset,>({
    client,
    args,
    options
  }: StardexPairShareQuery<TData>): UseQueryOptions<ArrayOfAsset, Error, TData> => ({
    queryKey: stardexPairQueryKeys.share(client?.contractAddress, args),
    queryFn: () => client ? client.share({
      amount: args.amount
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  simulation: <TData = SimulationResponse,>({
    client,
    args,
    options
  }: StardexPairSimulationQuery<TData>): UseQueryOptions<SimulationResponse, Error, TData> => ({
    queryKey: stardexPairQueryKeys.simulation(client?.contractAddress, args),
    queryFn: () => client ? client.simulation({
      askAssetInfo: args.askAssetInfo,
      offerAsset: args.offerAsset
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  reverseSimulation: <TData = ReverseSimulationResponse,>({
    client,
    args,
    options
  }: StardexPairReverseSimulationQuery<TData>): UseQueryOptions<ReverseSimulationResponse, Error, TData> => ({
    queryKey: stardexPairQueryKeys.reverseSimulation(client?.contractAddress, args),
    queryFn: () => client ? client.reverseSimulation({
      askAsset: args.askAsset,
      offerAssetInfo: args.offerAssetInfo
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  cumulativePrices: <TData = CumulativePricesResponse,>({
    client,
    options
  }: StardexPairCumulativePricesQuery<TData>): UseQueryOptions<CumulativePricesResponse, Error, TData> => ({
    queryKey: stardexPairQueryKeys.cumulativePrices(client?.contractAddress),
    queryFn: () => client ? client.cumulativePrices() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  queryComputeD: <TData = Uint128,>({
    client,
    options
  }: StardexPairQueryComputeDQuery<TData>): UseQueryOptions<Uint128, Error, TData> => ({
    queryKey: stardexPairQueryKeys.queryComputeD(client?.contractAddress),
    queryFn: () => client ? client.queryComputeD() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  assetBalanceAt: <TData = NullableUint128,>({
    client,
    args,
    options
  }: StardexPairAssetBalanceAtQuery<TData>): UseQueryOptions<NullableUint128, Error, TData> => ({
    queryKey: stardexPairQueryKeys.assetBalanceAt(client?.contractAddress, args),
    queryFn: () => client ? client.assetBalanceAt({
      assetInfo: args.assetInfo,
      blockHeight: args.blockHeight
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  observe: <TData = OracleObservation,>({
    client,
    args,
    options
  }: StardexPairObserveQuery<TData>): UseQueryOptions<OracleObservation, Error, TData> => ({
    queryKey: stardexPairQueryKeys.observe(client?.contractAddress, args),
    queryFn: () => client ? client.observe({
      secondsAgo: args.secondsAgo
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  simulateWithdraw: <TData = ArrayOfAsset,>({
    client,
    args,
    options
  }: StardexPairSimulateWithdrawQuery<TData>): UseQueryOptions<ArrayOfAsset, Error, TData> => ({
    queryKey: stardexPairQueryKeys.simulateWithdraw(client?.contractAddress, args),
    queryFn: () => client ? client.simulateWithdraw({
      lpAmount: args.lpAmount
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  simulateProvide: <TData = Uint128,>({
    client,
    args,
    options
  }: StardexPairSimulateProvideQuery<TData>): UseQueryOptions<Uint128, Error, TData> => ({
    queryKey: stardexPairQueryKeys.simulateProvide(client?.contractAddress, args),
    queryFn: () => client ? client.simulateProvide({
      assets: args.assets,
      slippageTolerance: args.slippageTolerance
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface StardexPairReactQuery<TResponse, TData = TResponse> {
  client: StardexPairQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface StardexPairSimulateProvideQuery<TData> extends StardexPairReactQuery<Uint128, TData> {
  args: {
    assets: Asset[];
    slippageTolerance?: Decimal;
  };
}
export function useStardexPairSimulateProvideQuery<TData = Uint128>({
  client,
  args,
  options
}: StardexPairSimulateProvideQuery<TData>) {
  return useQuery<Uint128, Error, TData>(stardexPairQueryKeys.simulateProvide(client?.contractAddress, args), () => client ? client.simulateProvide({
    assets: args.assets,
    slippageTolerance: args.slippageTolerance
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairSimulateWithdrawQuery<TData> extends StardexPairReactQuery<ArrayOfAsset, TData> {
  args: {
    lpAmount: Uint128;
  };
}
export function useStardexPairSimulateWithdrawQuery<TData = ArrayOfAsset>({
  client,
  args,
  options
}: StardexPairSimulateWithdrawQuery<TData>) {
  return useQuery<ArrayOfAsset, Error, TData>(stardexPairQueryKeys.simulateWithdraw(client?.contractAddress, args), () => client ? client.simulateWithdraw({
    lpAmount: args.lpAmount
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairObserveQuery<TData> extends StardexPairReactQuery<OracleObservation, TData> {
  args: {
    secondsAgo: number;
  };
}
export function useStardexPairObserveQuery<TData = OracleObservation>({
  client,
  args,
  options
}: StardexPairObserveQuery<TData>) {
  return useQuery<OracleObservation, Error, TData>(stardexPairQueryKeys.observe(client?.contractAddress, args), () => client ? client.observe({
    secondsAgo: args.secondsAgo
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairAssetBalanceAtQuery<TData> extends StardexPairReactQuery<NullableUint128, TData> {
  args: {
    assetInfo: AssetInfo;
    blockHeight: Uint64;
  };
}
export function useStardexPairAssetBalanceAtQuery<TData = NullableUint128>({
  client,
  args,
  options
}: StardexPairAssetBalanceAtQuery<TData>) {
  return useQuery<NullableUint128, Error, TData>(stardexPairQueryKeys.assetBalanceAt(client?.contractAddress, args), () => client ? client.assetBalanceAt({
    assetInfo: args.assetInfo,
    blockHeight: args.blockHeight
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairQueryComputeDQuery<TData> extends StardexPairReactQuery<Uint128, TData> {}
export function useStardexPairQueryComputeDQuery<TData = Uint128>({
  client,
  options
}: StardexPairQueryComputeDQuery<TData>) {
  return useQuery<Uint128, Error, TData>(stardexPairQueryKeys.queryComputeD(client?.contractAddress), () => client ? client.queryComputeD() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairCumulativePricesQuery<TData> extends StardexPairReactQuery<CumulativePricesResponse, TData> {}
export function useStardexPairCumulativePricesQuery<TData = CumulativePricesResponse>({
  client,
  options
}: StardexPairCumulativePricesQuery<TData>) {
  return useQuery<CumulativePricesResponse, Error, TData>(stardexPairQueryKeys.cumulativePrices(client?.contractAddress), () => client ? client.cumulativePrices() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairReverseSimulationQuery<TData> extends StardexPairReactQuery<ReverseSimulationResponse, TData> {
  args: {
    askAsset: Asset;
    offerAssetInfo?: AssetInfo;
  };
}
export function useStardexPairReverseSimulationQuery<TData = ReverseSimulationResponse>({
  client,
  args,
  options
}: StardexPairReverseSimulationQuery<TData>) {
  return useQuery<ReverseSimulationResponse, Error, TData>(stardexPairQueryKeys.reverseSimulation(client?.contractAddress, args), () => client ? client.reverseSimulation({
    askAsset: args.askAsset,
    offerAssetInfo: args.offerAssetInfo
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairSimulationQuery<TData> extends StardexPairReactQuery<SimulationResponse, TData> {
  args: {
    askAssetInfo?: AssetInfo;
    offerAsset: Asset;
  };
}
export function useStardexPairSimulationQuery<TData = SimulationResponse>({
  client,
  args,
  options
}: StardexPairSimulationQuery<TData>) {
  return useQuery<SimulationResponse, Error, TData>(stardexPairQueryKeys.simulation(client?.contractAddress, args), () => client ? client.simulation({
    askAssetInfo: args.askAssetInfo,
    offerAsset: args.offerAsset
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairShareQuery<TData> extends StardexPairReactQuery<ArrayOfAsset, TData> {
  args: {
    amount: Uint128;
  };
}
export function useStardexPairShareQuery<TData = ArrayOfAsset>({
  client,
  args,
  options
}: StardexPairShareQuery<TData>) {
  return useQuery<ArrayOfAsset, Error, TData>(stardexPairQueryKeys.share(client?.contractAddress, args), () => client ? client.share({
    amount: args.amount
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairConfigQuery<TData> extends StardexPairReactQuery<ConfigResponse, TData> {}
export function useStardexPairConfigQuery<TData = ConfigResponse>({
  client,
  options
}: StardexPairConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(stardexPairQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairPoolQuery<TData> extends StardexPairReactQuery<PoolResponse, TData> {}
export function useStardexPairPoolQuery<TData = PoolResponse>({
  client,
  options
}: StardexPairPoolQuery<TData>) {
  return useQuery<PoolResponse, Error, TData>(stardexPairQueryKeys.pool(client?.contractAddress), () => client ? client.pool() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairPairQuery<TData> extends StardexPairReactQuery<PairInfo, TData> {}
export function useStardexPairPairQuery<TData = PairInfo>({
  client,
  options
}: StardexPairPairQuery<TData>) {
  return useQuery<PairInfo, Error, TData>(stardexPairQueryKeys.pair(client?.contractAddress), () => client ? client.pair() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface StardexPairClaimOwnershipMutation {
  client: StardexPairClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairClaimOwnershipMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairClaimOwnershipMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairClaimOwnershipMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.claimOwnership(fee, memo, funds), options);
}
export interface StardexPairDropOwnershipProposalMutation {
  client: StardexPairClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairDropOwnershipProposalMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairDropOwnershipProposalMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairDropOwnershipProposalMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.dropOwnershipProposal(fee, memo, funds), options);
}
export interface StardexPairProposeNewOwnerMutation {
  client: StardexPairClient;
  msg: {
    expiresIn: number;
    owner: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairProposeNewOwnerMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairProposeNewOwnerMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairProposeNewOwnerMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.proposeNewOwner(msg, fee, memo, funds), options);
}
export interface StardexPairUpdateConfigMutation {
  client: StardexPairClient;
  msg: {
    params: Binary;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}
export interface StardexPairSwapMutation {
  client: StardexPairClient;
  msg: {
    askAssetInfo?: AssetInfo;
    beliefPrice?: Decimal;
    maxSpread?: Decimal;
    offerAsset: Asset;
    to?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairSwapMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairSwapMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairSwapMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.swap(msg, fee, memo, funds), options);
}
export interface StardexPairWithdrawLiquidityMutation {
  client: StardexPairClient;
  msg: {
    assets?: Asset[];
    minAssetsToReceive?: Asset[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairWithdrawLiquidityMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairWithdrawLiquidityMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairWithdrawLiquidityMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.withdrawLiquidity(msg, fee, memo, funds), options);
}
export interface StardexPairProvideLiquidityMutation {
  client: StardexPairClient;
  msg: {
    assets: Asset[];
    autoStake?: boolean;
    minLpToReceive?: Uint128;
    receiver?: string;
    slippageTolerance?: Decimal;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairProvideLiquidityMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairProvideLiquidityMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairProvideLiquidityMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.provideLiquidity(msg, fee, memo, funds), options);
}
export interface StardexPairReceiveMutation {
  client: StardexPairClient;
  msg: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useStardexPairReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, StardexPairReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, StardexPairReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receive(msg, fee, memo, funds), options);
}