"use strict";
/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStardexPairConcentratedReceiveMutation = exports.useStardexPairConcentratedProvideLiquidityMutation = exports.useStardexPairConcentratedWithdrawLiquidityMutation = exports.useStardexPairConcentratedSwapMutation = exports.useStardexPairConcentratedUpdateConfigMutation = exports.useStardexPairConcentratedProposeNewOwnerMutation = exports.useStardexPairConcentratedDropOwnershipProposalMutation = exports.useStardexPairConcentratedClaimOwnershipMutation = exports.useStardexPairConcentratedPairQuery = exports.useStardexPairConcentratedPoolQuery = exports.useStardexPairConcentratedConfigQuery = exports.useStardexPairConcentratedShareQuery = exports.useStardexPairConcentratedSimulationQuery = exports.useStardexPairConcentratedReverseSimulationQuery = exports.useStardexPairConcentratedCumulativePricesQuery = exports.useStardexPairConcentratedComputeDQuery = exports.useStardexPairConcentratedLpPriceQuery = exports.useStardexPairConcentratedAssetBalanceAtQuery = exports.useStardexPairConcentratedObserveQuery = exports.useStardexPairConcentratedSimulateProvideQuery = exports.useStardexPairConcentratedSimulateWithdrawQuery = exports.stardexPairConcentratedQueries = exports.stardexPairConcentratedQueryKeys = void 0;
const react_query_1 = require("@tanstack/react-query");
exports.stardexPairConcentratedQueryKeys = {
    contract: [{
            contract: "stardexPairConcentrated"
        }],
    address: (contractAddress) => [{
            ...exports.stardexPairConcentratedQueryKeys.contract[0],
            address: contractAddress
        }],
    pair: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "pair",
            args
        }],
    pool: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "pool",
            args
        }],
    config: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "config",
            args
        }],
    share: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "share",
            args
        }],
    simulation: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "simulation",
            args
        }],
    reverseSimulation: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "reverse_simulation",
            args
        }],
    cumulativePrices: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "cumulative_prices",
            args
        }],
    computeD: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "compute_d",
            args
        }],
    lpPrice: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "lp_price",
            args
        }],
    assetBalanceAt: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "asset_balance_at",
            args
        }],
    observe: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "observe",
            args
        }],
    simulateProvide: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "simulate_provide",
            args
        }],
    simulateWithdraw: (contractAddress, args) => [{
            ...exports.stardexPairConcentratedQueryKeys.address(contractAddress)[0],
            method: "simulate_withdraw",
            args
        }]
};
exports.stardexPairConcentratedQueries = {
    pair: ({ client, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.pair(client?.contractAddress),
        queryFn: () => client ? client.pair() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    pool: ({ client, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.pool(client?.contractAddress),
        queryFn: () => client ? client.pool() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    config: ({ client, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.config(client?.contractAddress),
        queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    share: ({ client, args, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.share(client?.contractAddress, args),
        queryFn: () => client ? client.share({
            amount: args.amount
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    simulation: ({ client, args, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.simulation(client?.contractAddress, args),
        queryFn: () => client ? client.simulation({
            askAssetInfo: args.askAssetInfo,
            offerAsset: args.offerAsset
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    reverseSimulation: ({ client, args, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.reverseSimulation(client?.contractAddress, args),
        queryFn: () => client ? client.reverseSimulation({
            askAsset: args.askAsset,
            offerAssetInfo: args.offerAssetInfo
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    cumulativePrices: ({ client, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.cumulativePrices(client?.contractAddress),
        queryFn: () => client ? client.cumulativePrices() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    computeD: ({ client, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.computeD(client?.contractAddress),
        queryFn: () => client ? client.computeD() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    lpPrice: ({ client, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.lpPrice(client?.contractAddress),
        queryFn: () => client ? client.lpPrice() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    assetBalanceAt: ({ client, args, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.assetBalanceAt(client?.contractAddress, args),
        queryFn: () => client ? client.assetBalanceAt({
            assetInfo: args.assetInfo,
            blockHeight: args.blockHeight
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    observe: ({ client, args, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.observe(client?.contractAddress, args),
        queryFn: () => client ? client.observe({
            secondsAgo: args.secondsAgo
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    simulateProvide: ({ client, args, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.simulateProvide(client?.contractAddress, args),
        queryFn: () => client ? client.simulateProvide({
            assets: args.assets,
            slippageTolerance: args.slippageTolerance
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    simulateWithdraw: ({ client, args, options }) => ({
        queryKey: exports.stardexPairConcentratedQueryKeys.simulateWithdraw(client?.contractAddress, args),
        queryFn: () => client ? client.simulateWithdraw({
            lpAmount: args.lpAmount
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    })
};
function useStardexPairConcentratedSimulateWithdrawQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.simulateWithdraw(client?.contractAddress, args), () => client ? client.simulateWithdraw({
        lpAmount: args.lpAmount
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedSimulateWithdrawQuery = useStardexPairConcentratedSimulateWithdrawQuery;
function useStardexPairConcentratedSimulateProvideQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.simulateProvide(client?.contractAddress, args), () => client ? client.simulateProvide({
        assets: args.assets,
        slippageTolerance: args.slippageTolerance
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedSimulateProvideQuery = useStardexPairConcentratedSimulateProvideQuery;
function useStardexPairConcentratedObserveQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.observe(client?.contractAddress, args), () => client ? client.observe({
        secondsAgo: args.secondsAgo
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedObserveQuery = useStardexPairConcentratedObserveQuery;
function useStardexPairConcentratedAssetBalanceAtQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.assetBalanceAt(client?.contractAddress, args), () => client ? client.assetBalanceAt({
        assetInfo: args.assetInfo,
        blockHeight: args.blockHeight
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedAssetBalanceAtQuery = useStardexPairConcentratedAssetBalanceAtQuery;
function useStardexPairConcentratedLpPriceQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.lpPrice(client?.contractAddress), () => client ? client.lpPrice() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedLpPriceQuery = useStardexPairConcentratedLpPriceQuery;
function useStardexPairConcentratedComputeDQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.computeD(client?.contractAddress), () => client ? client.computeD() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedComputeDQuery = useStardexPairConcentratedComputeDQuery;
function useStardexPairConcentratedCumulativePricesQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.cumulativePrices(client?.contractAddress), () => client ? client.cumulativePrices() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedCumulativePricesQuery = useStardexPairConcentratedCumulativePricesQuery;
function useStardexPairConcentratedReverseSimulationQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.reverseSimulation(client?.contractAddress, args), () => client ? client.reverseSimulation({
        askAsset: args.askAsset,
        offerAssetInfo: args.offerAssetInfo
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedReverseSimulationQuery = useStardexPairConcentratedReverseSimulationQuery;
function useStardexPairConcentratedSimulationQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.simulation(client?.contractAddress, args), () => client ? client.simulation({
        askAssetInfo: args.askAssetInfo,
        offerAsset: args.offerAsset
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedSimulationQuery = useStardexPairConcentratedSimulationQuery;
function useStardexPairConcentratedShareQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.share(client?.contractAddress, args), () => client ? client.share({
        amount: args.amount
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedShareQuery = useStardexPairConcentratedShareQuery;
function useStardexPairConcentratedConfigQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedConfigQuery = useStardexPairConcentratedConfigQuery;
function useStardexPairConcentratedPoolQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.pool(client?.contractAddress), () => client ? client.pool() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedPoolQuery = useStardexPairConcentratedPoolQuery;
function useStardexPairConcentratedPairQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairConcentratedQueryKeys.pair(client?.contractAddress), () => client ? client.pair() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConcentratedPairQuery = useStardexPairConcentratedPairQuery;
function useStardexPairConcentratedClaimOwnershipMutation(options) {
    return (0, react_query_1.useMutation)(({ client, args: { fee, memo, funds } = {} }) => client.claimOwnership(fee, memo, funds), options);
}
exports.useStardexPairConcentratedClaimOwnershipMutation = useStardexPairConcentratedClaimOwnershipMutation;
function useStardexPairConcentratedDropOwnershipProposalMutation(options) {
    return (0, react_query_1.useMutation)(({ client, args: { fee, memo, funds } = {} }) => client.dropOwnershipProposal(fee, memo, funds), options);
}
exports.useStardexPairConcentratedDropOwnershipProposalMutation = useStardexPairConcentratedDropOwnershipProposalMutation;
function useStardexPairConcentratedProposeNewOwnerMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.proposeNewOwner(msg, fee, memo, funds), options);
}
exports.useStardexPairConcentratedProposeNewOwnerMutation = useStardexPairConcentratedProposeNewOwnerMutation;
function useStardexPairConcentratedUpdateConfigMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.updateConfig(msg, fee, memo, funds), options);
}
exports.useStardexPairConcentratedUpdateConfigMutation = useStardexPairConcentratedUpdateConfigMutation;
function useStardexPairConcentratedSwapMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.swap(msg, fee, memo, funds), options);
}
exports.useStardexPairConcentratedSwapMutation = useStardexPairConcentratedSwapMutation;
function useStardexPairConcentratedWithdrawLiquidityMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.withdrawLiquidity(msg, fee, memo, funds), options);
}
exports.useStardexPairConcentratedWithdrawLiquidityMutation = useStardexPairConcentratedWithdrawLiquidityMutation;
function useStardexPairConcentratedProvideLiquidityMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.provideLiquidity(msg, fee, memo, funds), options);
}
exports.useStardexPairConcentratedProvideLiquidityMutation = useStardexPairConcentratedProvideLiquidityMutation;
function useStardexPairConcentratedReceiveMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.receive(msg, fee, memo, funds), options);
}
exports.useStardexPairConcentratedReceiveMutation = useStardexPairConcentratedReceiveMutation;
