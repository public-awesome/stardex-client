"use strict";
/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStardexPairReceiveMutation = exports.useStardexPairProvideLiquidityMutation = exports.useStardexPairWithdrawLiquidityMutation = exports.useStardexPairSwapMutation = exports.useStardexPairUpdateConfigMutation = exports.useStardexPairProposeNewOwnerMutation = exports.useStardexPairDropOwnershipProposalMutation = exports.useStardexPairClaimOwnershipMutation = exports.useStardexPairPairQuery = exports.useStardexPairPoolQuery = exports.useStardexPairConfigQuery = exports.useStardexPairShareQuery = exports.useStardexPairSimulationQuery = exports.useStardexPairReverseSimulationQuery = exports.useStardexPairCumulativePricesQuery = exports.useStardexPairQueryComputeDQuery = exports.useStardexPairAssetBalanceAtQuery = exports.useStardexPairObserveQuery = exports.useStardexPairSimulateWithdrawQuery = exports.useStardexPairSimulateProvideQuery = exports.stardexPairQueries = exports.stardexPairQueryKeys = void 0;
const react_query_1 = require("@tanstack/react-query");
exports.stardexPairQueryKeys = {
    contract: [{
            contract: "stardexPair"
        }],
    address: (contractAddress) => [{
            ...exports.stardexPairQueryKeys.contract[0],
            address: contractAddress
        }],
    pair: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "pair",
            args
        }],
    pool: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "pool",
            args
        }],
    config: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "config",
            args
        }],
    share: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "share",
            args
        }],
    simulation: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "simulation",
            args
        }],
    reverseSimulation: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "reverse_simulation",
            args
        }],
    cumulativePrices: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "cumulative_prices",
            args
        }],
    queryComputeD: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "query_compute_d",
            args
        }],
    assetBalanceAt: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "asset_balance_at",
            args
        }],
    observe: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "observe",
            args
        }],
    simulateWithdraw: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "simulate_withdraw",
            args
        }],
    simulateProvide: (contractAddress, args) => [{
            ...exports.stardexPairQueryKeys.address(contractAddress)[0],
            method: "simulate_provide",
            args
        }]
};
exports.stardexPairQueries = {
    pair: ({ client, options }) => ({
        queryKey: exports.stardexPairQueryKeys.pair(client?.contractAddress),
        queryFn: () => client ? client.pair() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    pool: ({ client, options }) => ({
        queryKey: exports.stardexPairQueryKeys.pool(client?.contractAddress),
        queryFn: () => client ? client.pool() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    config: ({ client, options }) => ({
        queryKey: exports.stardexPairQueryKeys.config(client?.contractAddress),
        queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    share: ({ client, args, options }) => ({
        queryKey: exports.stardexPairQueryKeys.share(client?.contractAddress, args),
        queryFn: () => client ? client.share({
            amount: args.amount
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    simulation: ({ client, args, options }) => ({
        queryKey: exports.stardexPairQueryKeys.simulation(client?.contractAddress, args),
        queryFn: () => client ? client.simulation({
            askAssetInfo: args.askAssetInfo,
            offerAsset: args.offerAsset
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    reverseSimulation: ({ client, args, options }) => ({
        queryKey: exports.stardexPairQueryKeys.reverseSimulation(client?.contractAddress, args),
        queryFn: () => client ? client.reverseSimulation({
            askAsset: args.askAsset,
            offerAssetInfo: args.offerAssetInfo
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    cumulativePrices: ({ client, options }) => ({
        queryKey: exports.stardexPairQueryKeys.cumulativePrices(client?.contractAddress),
        queryFn: () => client ? client.cumulativePrices() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    queryComputeD: ({ client, options }) => ({
        queryKey: exports.stardexPairQueryKeys.queryComputeD(client?.contractAddress),
        queryFn: () => client ? client.queryComputeD() : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    assetBalanceAt: ({ client, args, options }) => ({
        queryKey: exports.stardexPairQueryKeys.assetBalanceAt(client?.contractAddress, args),
        queryFn: () => client ? client.assetBalanceAt({
            assetInfo: args.assetInfo,
            blockHeight: args.blockHeight
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    observe: ({ client, args, options }) => ({
        queryKey: exports.stardexPairQueryKeys.observe(client?.contractAddress, args),
        queryFn: () => client ? client.observe({
            secondsAgo: args.secondsAgo
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    simulateWithdraw: ({ client, args, options }) => ({
        queryKey: exports.stardexPairQueryKeys.simulateWithdraw(client?.contractAddress, args),
        queryFn: () => client ? client.simulateWithdraw({
            lpAmount: args.lpAmount
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    }),
    simulateProvide: ({ client, args, options }) => ({
        queryKey: exports.stardexPairQueryKeys.simulateProvide(client?.contractAddress, args),
        queryFn: () => client ? client.simulateProvide({
            assets: args.assets,
            slippageTolerance: args.slippageTolerance
        }) : Promise.reject(new Error("Invalid client")),
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    })
};
function useStardexPairSimulateProvideQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.simulateProvide(client?.contractAddress, args), () => client ? client.simulateProvide({
        assets: args.assets,
        slippageTolerance: args.slippageTolerance
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairSimulateProvideQuery = useStardexPairSimulateProvideQuery;
function useStardexPairSimulateWithdrawQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.simulateWithdraw(client?.contractAddress, args), () => client ? client.simulateWithdraw({
        lpAmount: args.lpAmount
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairSimulateWithdrawQuery = useStardexPairSimulateWithdrawQuery;
function useStardexPairObserveQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.observe(client?.contractAddress, args), () => client ? client.observe({
        secondsAgo: args.secondsAgo
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairObserveQuery = useStardexPairObserveQuery;
function useStardexPairAssetBalanceAtQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.assetBalanceAt(client?.contractAddress, args), () => client ? client.assetBalanceAt({
        assetInfo: args.assetInfo,
        blockHeight: args.blockHeight
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairAssetBalanceAtQuery = useStardexPairAssetBalanceAtQuery;
function useStardexPairQueryComputeDQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.queryComputeD(client?.contractAddress), () => client ? client.queryComputeD() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairQueryComputeDQuery = useStardexPairQueryComputeDQuery;
function useStardexPairCumulativePricesQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.cumulativePrices(client?.contractAddress), () => client ? client.cumulativePrices() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairCumulativePricesQuery = useStardexPairCumulativePricesQuery;
function useStardexPairReverseSimulationQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.reverseSimulation(client?.contractAddress, args), () => client ? client.reverseSimulation({
        askAsset: args.askAsset,
        offerAssetInfo: args.offerAssetInfo
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairReverseSimulationQuery = useStardexPairReverseSimulationQuery;
function useStardexPairSimulationQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.simulation(client?.contractAddress, args), () => client ? client.simulation({
        askAssetInfo: args.askAssetInfo,
        offerAsset: args.offerAsset
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairSimulationQuery = useStardexPairSimulationQuery;
function useStardexPairShareQuery({ client, args, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.share(client?.contractAddress, args), () => client ? client.share({
        amount: args.amount
    }) : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairShareQuery = useStardexPairShareQuery;
function useStardexPairConfigQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairConfigQuery = useStardexPairConfigQuery;
function useStardexPairPoolQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.pool(client?.contractAddress), () => client ? client.pool() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairPoolQuery = useStardexPairPoolQuery;
function useStardexPairPairQuery({ client, options }) {
    return (0, react_query_1.useQuery)(exports.stardexPairQueryKeys.pair(client?.contractAddress), () => client ? client.pair() : Promise.reject(new Error("Invalid client")), {
        ...options,
        enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
    });
}
exports.useStardexPairPairQuery = useStardexPairPairQuery;
function useStardexPairClaimOwnershipMutation(options) {
    return (0, react_query_1.useMutation)(({ client, args: { fee, memo, funds } = {} }) => client.claimOwnership(fee, memo, funds), options);
}
exports.useStardexPairClaimOwnershipMutation = useStardexPairClaimOwnershipMutation;
function useStardexPairDropOwnershipProposalMutation(options) {
    return (0, react_query_1.useMutation)(({ client, args: { fee, memo, funds } = {} }) => client.dropOwnershipProposal(fee, memo, funds), options);
}
exports.useStardexPairDropOwnershipProposalMutation = useStardexPairDropOwnershipProposalMutation;
function useStardexPairProposeNewOwnerMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.proposeNewOwner(msg, fee, memo, funds), options);
}
exports.useStardexPairProposeNewOwnerMutation = useStardexPairProposeNewOwnerMutation;
function useStardexPairUpdateConfigMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.updateConfig(msg, fee, memo, funds), options);
}
exports.useStardexPairUpdateConfigMutation = useStardexPairUpdateConfigMutation;
function useStardexPairSwapMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.swap(msg, fee, memo, funds), options);
}
exports.useStardexPairSwapMutation = useStardexPairSwapMutation;
function useStardexPairWithdrawLiquidityMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.withdrawLiquidity(msg, fee, memo, funds), options);
}
exports.useStardexPairWithdrawLiquidityMutation = useStardexPairWithdrawLiquidityMutation;
function useStardexPairProvideLiquidityMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.provideLiquidity(msg, fee, memo, funds), options);
}
exports.useStardexPairProvideLiquidityMutation = useStardexPairProvideLiquidityMutation;
function useStardexPairReceiveMutation(options) {
    return (0, react_query_1.useMutation)(({ client, msg, args: { fee, memo, funds } = {} }) => client.receive(msg, fee, memo, funds), options);
}
exports.useStardexPairReceiveMutation = useStardexPairReceiveMutation;
