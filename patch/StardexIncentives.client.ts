/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.30.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  CosmWasmClient,
  SigningCosmWasmClient,
  ExecuteResult,
} from '@cosmjs/cosmwasm-stargate'
import { StdFee } from '@cosmjs/amino'
import {
  AssetInfo,
  Addr,
  Uint128,
  InstantiateMsg,
  IncentivizationFeeInfo,
  Coin,
  ExecuteMsg,
  Binary,
  Cw20ReceiveMsg,
  InputSchedule,
  Asset,
  QueryMsg,
  ArrayOfAssetInfo,
  Config,
  Decimal,
  ArrayOfScheduleResponse,
  ScheduleResponse,
  Boolean,
  ArrayOfAsset,
  RewardType,
  PoolInfoResponse,
  RewardInfo,
  ArrayOfTupleOfStringAndUint128,
  ArrayOfRewardInfo,
} from './StardexIncentives.types'
export interface StardexIncentivesReadOnlyInterface {
  contractAddress: string
  config: () => Promise<Config>
  deposit: ({
    lpToken,
    user,
  }: {
    lpToken: string
    user: string
  }) => Promise<Uint128>
  pendingRewards: ({
    lpToken,
    user,
  }: {
    lpToken: string
    user: string
  }) => Promise<ArrayOfAsset>
  rewardInfo: ({ lpToken }: { lpToken: string }) => Promise<ArrayOfRewardInfo>
  poolInfo: ({ lpToken }: { lpToken: string }) => Promise<PoolInfoResponse>
  poolStakers: ({
    limit,
    lpToken,
    startAfter,
  }: {
    limit?: number
    lpToken: string
    startAfter?: string
  }) => Promise<ArrayOfTupleOfStringAndUint128>
  blockedTokensList: ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: AssetInfo
  }) => Promise<ArrayOfAssetInfo>
  isFeeExpected: ({
    lpToken,
    reward,
  }: {
    lpToken: string
    reward: string
  }) => Promise<Boolean>
  externalRewardSchedules: ({
    limit,
    lpToken,
    reward,
    startAfter,
  }: {
    limit?: number
    lpToken: string
    reward: string
    startAfter?: number
  }) => Promise<ArrayOfScheduleResponse>
}
export class StardexIncentivesQueryClient
  implements StardexIncentivesReadOnlyInterface
{
  client: CosmWasmClient
  contractAddress: string

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.config = this.config.bind(this)
    this.deposit = this.deposit.bind(this)
    this.pendingRewards = this.pendingRewards.bind(this)
    this.rewardInfo = this.rewardInfo.bind(this)
    this.poolInfo = this.poolInfo.bind(this)
    this.poolStakers = this.poolStakers.bind(this)
    this.blockedTokensList = this.blockedTokensList.bind(this)
    this.isFeeExpected = this.isFeeExpected.bind(this)
    this.externalRewardSchedules = this.externalRewardSchedules.bind(this)
  }

  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    })
  }
  deposit = async ({
    lpToken,
    user,
  }: {
    lpToken: string
    user: string
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      deposit: {
        lp_token: lpToken,
        user,
      },
    })
  }
  pendingRewards = async ({
    lpToken,
    user,
  }: {
    lpToken: string
    user: string
  }): Promise<ArrayOfAsset> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pending_rewards: {
        lp_token: lpToken,
        user,
      },
    })
  }
  rewardInfo = async ({
    lpToken,
  }: {
    lpToken: string
  }): Promise<ArrayOfRewardInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reward_info: {
        lp_token: lpToken,
      },
    })
  }
  poolInfo = async ({
    lpToken,
  }: {
    lpToken: string
  }): Promise<PoolInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pool_info: {
        lp_token: lpToken,
      },
    })
  }
  poolStakers = async ({
    limit,
    lpToken,
    startAfter,
  }: {
    limit?: number
    lpToken: string
    startAfter?: string
  }): Promise<ArrayOfTupleOfStringAndUint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pool_stakers: {
        limit,
        lp_token: lpToken,
        start_after: startAfter,
      },
    })
  }
  blockedTokensList = async ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: AssetInfo
  }): Promise<ArrayOfAssetInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      blocked_tokens_list: {
        limit,
        start_after: startAfter,
      },
    })
  }
  isFeeExpected = async ({
    lpToken,
    reward,
  }: {
    lpToken: string
    reward: string
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_fee_expected: {
        lp_token: lpToken,
        reward,
      },
    })
  }
  externalRewardSchedules = async ({
    limit,
    lpToken,
    reward,
    startAfter,
  }: {
    limit?: number
    lpToken: string
    reward: string
    startAfter?: number
  }): Promise<ArrayOfScheduleResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      external_reward_schedules: {
        limit,
        lp_token: lpToken,
        reward,
        start_after: startAfter,
      },
    })
  }
}
export interface StardexIncentivesInterface
  extends StardexIncentivesReadOnlyInterface {
  contractAddress: string
  sender: string
  setupPools: (
    {
      pools,
    }: {
      pools: string[][]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  claimRewards: (
    {
      lpTokens,
    }: {
      lpTokens: string[]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  receive: (
    {
      amount,
      msg,
      sender,
    }: {
      amount: Uint128
      msg: Binary
      sender: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  depositIncentives: (
    {
      recipient,
    }: {
      recipient?: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  withdraw: (
    {
      amount,
      lpToken,
    }: {
      amount: Uint128
      lpToken: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  setTokensPerSecond: (
    {
      amount,
    }: {
      amount: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  incentivize: (
    {
      lpToken,
      schedule,
    }: {
      lpToken: string
      schedule: InputSchedule
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  removeRewardFromPool: (
    {
      bypassUpcomingSchedules,
      lpToken,
      receiver,
      reward,
    }: {
      bypassUpcomingSchedules: boolean
      lpToken: string
      receiver: string
      reward: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  claimOrphanedRewards: (
    {
      limit,
      receiver,
    }: {
      limit?: number
      receiver: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  updateConfig: (
    {
      generatorController,
      guardian,
      incentivizationFeeInfo,
      vestingContract,
    }: {
      generatorController?: string
      guardian?: string
      incentivizationFeeInfo?: IncentivizationFeeInfo
      vestingContract?: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  updateBlockedTokenslist: (
    {
      add,
      remove,
    }: {
      add?: AssetInfo[]
      remove?: AssetInfo[]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  deactivatePool: (
    {
      lpToken,
    }: {
      lpToken: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  deactivateBlockedPools: (
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  proposeNewOwner: (
    {
      expiresIn,
      owner,
    }: {
      expiresIn: number
      owner: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  dropOwnershipProposal: (
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  claimOwnership: (
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
}
export class StardexIncentivesClient
  extends StardexIncentivesQueryClient
  implements StardexIncentivesInterface
{
  client: SigningCosmWasmClient
  sender: string
  contractAddress: string

  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string,
  ) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.setupPools = this.setupPools.bind(this)
    this.claimRewards = this.claimRewards.bind(this)
    this.receive = this.receive.bind(this)
    this.deposit = this.deposit.bind(this)
    this.withdraw = this.withdraw.bind(this)
    this.setTokensPerSecond = this.setTokensPerSecond.bind(this)
    this.incentivize = this.incentivize.bind(this)
    this.removeRewardFromPool = this.removeRewardFromPool.bind(this)
    this.claimOrphanedRewards = this.claimOrphanedRewards.bind(this)
    this.updateConfig = this.updateConfig.bind(this)
    this.updateBlockedTokenslist = this.updateBlockedTokenslist.bind(this)
    this.deactivatePool = this.deactivatePool.bind(this)
    this.deactivateBlockedPools = this.deactivateBlockedPools.bind(this)
    this.proposeNewOwner = this.proposeNewOwner.bind(this)
    this.dropOwnershipProposal = this.dropOwnershipProposal.bind(this)
    this.claimOwnership = this.claimOwnership.bind(this)
  }

  setupPools = async (
    {
      pools,
    }: {
      pools: string[][]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        setup_pools: {
          pools,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  claimRewards = async (
    {
      lpTokens,
    }: {
      lpTokens: string[]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_rewards: {
          lp_tokens: lpTokens,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  receive = async (
    {
      amount,
      msg,
      sender,
    }: {
      amount: Uint128
      msg: Binary
      sender: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        receive: {
          amount,
          msg,
          sender,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  depositIncentives = async (
    {
      recipient,
    }: {
      recipient?: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        deposit: {
          recipient,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  withdraw = async (
    {
      amount,
      lpToken,
    }: {
      amount: Uint128
      lpToken: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        withdraw: {
          amount,
          lp_token: lpToken,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  setTokensPerSecond = async (
    {
      amount,
    }: {
      amount: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_tokens_per_second: {
          amount,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  incentivize = async (
    {
      lpToken,
      schedule,
    }: {
      lpToken: string
      schedule: InputSchedule
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        incentivize: {
          lp_token: lpToken,
          schedule,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  removeRewardFromPool = async (
    {
      bypassUpcomingSchedules,
      lpToken,
      receiver,
      reward,
    }: {
      bypassUpcomingSchedules: boolean
      lpToken: string
      receiver: string
      reward: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_reward_from_pool: {
          bypass_upcoming_schedules: bypassUpcomingSchedules,
          lp_token: lpToken,
          receiver,
          reward,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  claimOrphanedRewards = async (
    {
      limit,
      receiver,
    }: {
      limit?: number
      receiver: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_orphaned_rewards: {
          limit,
          receiver,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  updateConfig = async (
    {
      generatorController,
      guardian,
      incentivizationFeeInfo,
      vestingContract,
    }: {
      generatorController?: string
      guardian?: string
      incentivizationFeeInfo?: IncentivizationFeeInfo
      vestingContract?: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_config: {
          generator_controller: generatorController,
          guardian,
          incentivization_fee_info: incentivizationFeeInfo,
          vesting_contract: vestingContract,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  updateBlockedTokenslist = async (
    {
      add,
      remove,
    }: {
      add?: AssetInfo[]
      remove?: AssetInfo[]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_blocked_tokenslist: {
          add,
          remove,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  deactivatePool = async (
    {
      lpToken,
    }: {
      lpToken: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        deactivate_pool: {
          lp_token: lpToken,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  deactivateBlockedPools = async (
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        deactivate_blocked_pools: {},
      },
      fee,
      memo,
      _funds,
    )
  }
  proposeNewOwner = async (
    {
      expiresIn,
      owner,
    }: {
      expiresIn: number
      owner: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        propose_new_owner: {
          expires_in: expiresIn,
          owner,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  dropOwnershipProposal = async (
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        drop_ownership_proposal: {},
      },
      fee,
      memo,
      _funds,
    )
  }
  claimOwnership = async (
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_ownership: {},
      },
      fee,
      memo,
      _funds,
    )
  }
}
